{
  "activationDate": "2015-11-26T12:00:00.000Z",
  "dueDate": "2016-02-01T12:00:00.000Z",
  "id": "a6eb531e-a530-43c5-aeba-61b121ddbac4",
  "internals": {
    "error": [],
    "source": "# Übung 9 – Kollisionsstrategien\n\n## Quadratisches Sondieren (20 Punkte)\n\nGegeben sei die folgende Hashtabelle\n\n| 0 | 1 | 2 | 3 | 4 |\n|:-:|:-:|:-:|:-:|:-:|\n|   | 17| 3 |   | 12|\n\nFügen Sie mit den folgenden Kollisionsstrategien die Zahl $11$ ein:\n\n - Linearen Sondieren\n - Double Hashing mit $h_2(k) = (k \\ mod \\ 3) + 1$\n - Quadratisches Sondieren\n\nRecherchieren Sie selbständig nach der Funktionsweise von quadratischem Hashing.\n\n### Prefilled\n\n| $k$ | $h_1(k)$ | $h_2(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|\n| $13$|          |          |   |   |   |   |   |\n\n### Solution\n\n - Lineares Sondieren\n\n| $k$ | $h_1(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:-:|:-:|:-:|:-:|:-:|\n|     |          |   | 17| 3 |   | 12|\n| 11  |    1     |   | → | → | 11| 12|\n\n - Double Hashing\n\n| $k$ | $h_1(k)$ | $h_2(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|\n|     |          |          |   | 17| 3 |   | 12|\n| 11  |     1    |    3     |   | → |(→)|(→)| → |\n| 11  |     1    |    3     |(→)|(→)| → |(→)|(→)|\n| 11  |     1    |    3     | 11|   |   |   |   |\n\n - Quadratisches Sondieren\n\n| $k$ | $h_1(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:-:|:-:|:-:|:-:|:-:|\n|     |          |   | 17| 3 |   | 12|\n| 11  |     1    |   | → | → |(→)|(→)|\n| 11  |     1    | 11|   |   |   |   |\n\n## Kollisionsvergleich\n\nDie verschiedenen Kollisionsstrategien haben bei verschiedenen Füllgraden\n$\\alpha$ unterschiedliche mittlere Kollisionszahlen. Dies soll nun praktisch\ndargestellt werden. Dafür benötigen Sie eine Implementierung der einzelnen\nKollisionsstrategien (Lineares Sondieren, Double Hashing und quadratisches\nSondieren) und ein Programm, das die mittlere Kollisionszahl für einen Füllgrad\nberechnet. Schreiben Sie diese Funktionen und Vergleichen Sie die Ausgaben\nmit denen, die theoretisch erwartet werden.\n\n### Prefilled\n\n```js\n// Funktion für das lineare Sondieren.\n// Eingaben:\n// - x: Wert der in der Tabelle abgespeichert werden soll\n// - table: Die Hashtabelle die verwendet werden soll (Referenz)\n// Ausgabe:\n// - Das x wird in die Tabelle eingefügt. Zurückgegeben wird aber die Anzahl\n//   der Versuche die zum Einfügen benötigt wurden. Also beim sofortigem\n//   Einfügen 1, bei einer Kollision 2, etc.\nfunction linearProbing(x, table){\n  // implementieren\n}\n\n// Funktion für das double Hashing.\n// Eingaben:\n// - x: Wert der in der Tabelle abgespeichert werden soll\n// - table: Die Hashtabelle die verwendet werden soll\n// - h2: Funktion die den zweiten Hashwert berechnet\nfunction doubleHashing(x, table, h2){\n  // implementieren\n}\n\n// Funktion für das quadratische Sondieren.\n// Eingaben:\n// - x: Wert der in der Tabelle abgespeichert werden soll\n// - table: Die Hashtabelle die verwendet werden soll\nfunction quadraticProbing(x, table){\n  // implementieren\n}\n\n\n// Funktion die die mittlere Kollisionszahl für eine Tabelle der\n// Größe n empirisch bestimmt.\n// Eingaben:\n// - alpha: Füllgrad (englisch load factor)\n// - n: Größe/Länge der Tabelle\nfunction probeLoadFactor(alpha, n){\n  // implementieren\n}\n\n// Funktion die eine Kollisionsstrategien mit den gegebenen alpha Werten\n// testet. D.h. die mittlere Kollisionszahlen für die einzelnen Alpha\n// Werte berechnet.\n// Eingaben:\n// - fn: Die Funktion die getestet werden soll (z.B. linearProbing)\n// - alphas: Ein Array von alpha Werten die getestet werden sollen\n// - n: Größe/Länge der Tabelle die getestet werden soll.\nfunction probeMethod(fn, alphas, n){\n  // implementieren\n}\n\n// Native Möglichkeit ein Array zu initialisieren. \nvar alphas = (Array.apply(null, Array(100)))\n  .map(function(n,idx){ return idx/(100 - 1); })\n```\n\n```\nplot(probeMethod(linearProbing, alphas, 541))\nplot(probeMethod(doubleHashing, alphas, 541))\nplot(probeMethod(quadraticProbing, alphas, 541))\n```\n\n### Tests\n\n```tests\nit(\"[Lineares Sondieren] Einfügen in eine leere Tabelle benötigt einen Versuchen\", function(){\n  var res = linearProbing(0, new Array(3));\n  if(res != 1){\n    throw \"Einfügen in eine leere Tabelle gibt nicht 1 zurück.\";\n  }\n})\nit(\"[Double Hashing] Einfügen in eine leere Tabelle benötigt einen Versuchen\", function(){\n  var res = doubleHashing(0, new Array(3));\n  if(res != 1){\n    throw \"Einfügen in eine leere Tabelle gibt nicht 1 zurück.\";\n  }\n})\nit(\"[Quadratisches Sondieren] Einfügen in eine leere Tabelle benötigt einen Versuchen\", function(){\n  var res = quadraticProbing(0, new Array(3));\n  if(res != 1){\n    throw \"Einfügen in eine leere Tabelle gibt nicht 1 zurück.\";\n  }\n})\n```\n"
  },
  "number": "9",
  "tasks": [
    {
      "maxPoints": "20",
      "number": 1,
      "prefilled": "| $k$ | $h_1(k)$ | $h_2(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|\n| $13$|          |          |   |   |   |   |   |",
      "solution": " - Lineares Sondieren\n\n| $k$ | $h_1(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:-:|:-:|:-:|:-:|:-:|\n|     |          |   | 17| 3 |   | 12|\n| 11  |    1     |   | → | → | 11| 12|\n\n - Double Hashing\n\n| $k$ | $h_1(k)$ | $h_2(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|\n|     |          |          |   | 17| 3 |   | 12|\n| 11  |     1    |    3     |   | → |(→)|(→)| → |\n| 11  |     1    |    3     |(→)|(→)| → |(→)|(→)|\n| 11  |     1    |    3     | 11|   |   |   |   |\n\n - Quadratisches Sondieren\n\n| $k$ | $h_1(k)$ | 0 | 1 | 2 | 3 | 4 |\n|:---:|:--------:|:-:|:-:|:-:|:-:|:-:|\n|     |          |   | 17| 3 |   | 12|\n| 11  |     1    |   | → | → |(→)|(→)|\n| 11  |     1    | 11|   |   |   |   |",
      "solutionTests": "",
      "tests": "",
      "text": "Gegeben sei die folgende Hashtabelle\n\n| 0 | 1 | 2 | 3 | 4 |\n|:-:|:-:|:-:|:-:|:-:|\n|   | 17| 3 |   | 12|\n\nFügen Sie mit den folgenden Kollisionsstrategien die Zahl $11$ ein:\n\n - Linearen Sondieren\n - Double Hashing mit $h_2(k) = (k \\ mod \\ 3) + 1$\n - Quadratisches Sondieren\n\nRecherchieren Sie selbständig nach der Funktionsweise von quadratischem Hashing.",
      "title": "Quadratisches Sondieren"
    },
    {
      "number": 2,
      "prefilled": "```js\n// Funktion für das lineare Sondieren.\n// Eingaben:\n// - x: Wert der in der Tabelle abgespeichert werden soll\n// - table: Die Hashtabelle die verwendet werden soll (Referenz)\n// Ausgabe:\n// - Das x wird in die Tabelle eingefügt. Zurückgegeben wird aber die Anzahl\n//   der Versuche die zum Einfügen benötigt wurden. Also beim sofortigem\n//   Einfügen 1, bei einer Kollision 2, etc.\nfunction linearProbing(x, table){\n  // implementieren\n}\n\n// Funktion für das double Hashing.\n// Eingaben:\n// - x: Wert der in der Tabelle abgespeichert werden soll\n// - table: Die Hashtabelle die verwendet werden soll\n// - h2: Funktion die den zweiten Hashwert berechnet\nfunction doubleHashing(x, table, h2){\n  // implementieren\n}\n\n// Funktion für das quadratische Sondieren.\n// Eingaben:\n// - x: Wert der in der Tabelle abgespeichert werden soll\n// - table: Die Hashtabelle die verwendet werden soll\nfunction quadraticProbing(x, table){\n  // implementieren\n}\n\n\n// Funktion die die mittlere Kollisionszahl für eine Tabelle der\n// Größe n empirisch bestimmt.\n// Eingaben:\n// - alpha: Füllgrad (englisch load factor)\n// - n: Größe/Länge der Tabelle\nfunction probeLoadFactor(alpha, n){\n  // implementieren\n}\n\n// Funktion die eine Kollisionsstrategien mit den gegebenen alpha Werten\n// testet. D.h. die mittlere Kollisionszahlen für die einzelnen Alpha\n// Werte berechnet.\n// Eingaben:\n// - fn: Die Funktion die getestet werden soll (z.B. linearProbing)\n// - alphas: Ein Array von alpha Werten die getestet werden sollen\n// - n: Größe/Länge der Tabelle die getestet werden soll.\nfunction probeMethod(fn, alphas, n){\n  // implementieren\n}\n\n// Native Möglichkeit ein Array zu initialisieren. \nvar alphas = (Array.apply(null, Array(100)))\n  .map(function(n,idx){ return idx/(100 - 1); })\n```\n\n```\nplot(probeMethod(linearProbing, alphas, 541))\nplot(probeMethod(doubleHashing, alphas, 541))\nplot(probeMethod(quadraticProbing, alphas, 541))\n```",
      "solution": "",
      "solutionTests": "",
      "tests": "```tests\nit(\"[Lineares Sondieren] Einfügen in eine leere Tabelle benötigt einen Versuchen\", function(){\n  var res = linearProbing(0, new Array(3));\n  if(res != 1){\n    throw \"Einfügen in eine leere Tabelle gibt nicht 1 zurück.\";\n  }\n})\nit(\"[Double Hashing] Einfügen in eine leere Tabelle benötigt einen Versuchen\", function(){\n  var res = doubleHashing(0, new Array(3));\n  if(res != 1){\n    throw \"Einfügen in eine leere Tabelle gibt nicht 1 zurück.\";\n  }\n})\nit(\"[Quadratisches Sondieren] Einfügen in eine leere Tabelle benötigt einen Versuchen\", function(){\n  var res = quadraticProbing(0, new Array(3));\n  if(res != 1){\n    throw \"Einfügen in eine leere Tabelle gibt nicht 1 zurück.\";\n  }\n})\n```",
      "text": "Die verschiedenen Kollisionsstrategien haben bei verschiedenen Füllgraden\n$\\alpha$ unterschiedliche mittlere Kollisionszahlen. Dies soll nun praktisch\ndargestellt werden. Dafür benötigen Sie eine Implementierung der einzelnen\nKollisionsstrategien (Lineares Sondieren, Double Hashing und quadratisches\nSondieren) und ein Programm, das die mittlere Kollisionszahl für einen Füllgrad\nberechnet. Schreiben Sie diese Funktionen und Vergleichen Sie die Ausgaben\nmit denen, die theoretisch erwartet werden.",
      "title": "Kollisionsvergleich"
    }
  ],
  "title": "Übung 9 – Kollisionsstrategien"
}